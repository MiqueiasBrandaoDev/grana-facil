/**
 * üöÄ SERVIDOR SIMPLES - FRONTEND + API WEBHOOK
 * Vers√£o simplificada sem problemas de roteamento
 */

const express = require('express');
const path = require('path');
const cors = require('cors');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware b√°sico
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Configura√ß√£o do ambiente
const SUPABASE_URL = process.env.VITE_SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.VITE_SUPABASE_ANON_KEY;
const EVOLUTION_API_URL = process.env.VITE_EVOLUTION_API_URL;
const EVOLUTION_API_KEY = process.env.VITE_EVOLUTION_API_KEY;
const EVOLUTION_INSTANCE_NAME = process.env.VITE_EVOLUTION_INSTANCE_NAME;

console.log('üîß Configura√ß√£o do servidor:');
console.log(`Supabase URL: ${SUPABASE_URL ? '‚úÖ Configurado' : '‚ùå N√£o configurado'}`);
console.log(`Evolution API: ${EVOLUTION_API_URL ? '‚úÖ Configurado' : '‚ùå N√£o configurado'}`);
console.log(`API Key: ${EVOLUTION_API_KEY ? '‚úÖ Configurado' : '‚ùå N√£o configurado'}`);
console.log(`Instance: ${EVOLUTION_INSTANCE_NAME || '‚ùå N√£o configurado'}`);

// ==========================================
// üì± ENDPOINTS DA API - ORDEM IMPORTANTE!
// ==========================================

/**
 * üì± WEBHOOK EVOLUTION API - ENDPOINT PRINCIPAL
 */
app.post('/api/evolution/webhook', async (req, res) => {
  console.log('\\nüéØ WEBHOOK RECEBIDO!');
  console.log('Timestamp:', new Date().toISOString());
  console.log('URL:', req.url);
  console.log('Method:', req.method);
  console.log('Body:', JSON.stringify(req.body, null, 2));

  try {
    const payload = req.body;
    
    // Verificar se √© mensagem v√°lida
    if (payload.event !== 'messages.upsert' || !payload.data) {
      console.log(`‚ö†Ô∏è Evento ignorado: ${payload.event}`);
      return res.status(200).json({ success: true, message: 'Evento ignorado' });
    }

    // Verificar se n√£o √© mensagem nossa
    if (payload.data.key?.fromMe) {
      console.log('üì§ Mensagem nossa, ignorando');
      return res.status(200).json({ success: true, message: 'Mensagem pr√≥pria ignorada' });
    }

    // Extrair dados
    const phoneNumber = payload.data.key?.remoteJid?.replace('@s.whatsapp.net', '');
    const messageText = payload.data.message?.conversation || 
                       payload.data.message?.extendedTextMessage?.text;
    const senderName = payload.data.pushName || `Usu√°rio ${phoneNumber?.slice(-4)}`;

    if (!messageText || !phoneNumber) {
      console.log('‚ùå Mensagem inv√°lida');
      return res.status(200).json({ success: true, message: 'Mensagem inv√°lida' });
    }

    console.log(`üì® De: ${senderName} (${phoneNumber})`);
    console.log(`üìù Texto: ${messageText}`);

    // Mostrar "digitando..." antes de processar
    await setTypingIndicator(phoneNumber, true);
    
    // Processar mensagem
    await processMessage(phoneNumber, messageText, senderName);
    
    // Parar "digitando..."
    await setTypingIndicator(phoneNumber, false);

    console.log('‚úÖ Processamento conclu√≠do');
    res.status(200).json({ success: true, message: 'Processado' });

  } catch (error) {
    console.error('‚ùå Erro no webhook:', error);
    console.error('Stack:', error.stack);
    
    // Sempre retornar 200
    res.status(200).json({ 
      success: false, 
      error: error.message 
    });
  }
});

/**
 * üìä STATUS DA API
 */
app.get('/api/evolution/status', (req, res) => {
  res.json({
    server: 'Grana F√°cil Webhook Server',
    status: 'running',
    timestamp: new Date().toISOString(),
    environment: {
      supabaseUrl: SUPABASE_URL ? 'Configurado' : 'N√£o configurado',
      evolutionApiUrl: EVOLUTION_API_URL ? 'Configurado' : 'N√£o configurado',
      evolutionApiKey: EVOLUTION_API_KEY ? 'Configurado' : 'N√£o configurado',
      instanceName: EVOLUTION_INSTANCE_NAME || 'N√£o configurado'
    }
  });
});

// ==========================================
// ü§ñ AI FINANCIAL AGENT - VERS√ÉO COMPLETA
// Mesma implementa√ß√£o da interface web
// ==========================================

const OPENAI_API_KEY = process.env.VITE_OPENAI_API_KEY;

/**
 * ü§ñ AGENTE IA FINANCEIRO COMPLETO
 * Integra√ß√£o total com todas as funcionalidades da web
 */
class AIFinancialAgent {
  constructor() {
    this.userContext = null;
    this.conversationHistory = [];
  }

  /**
   * üß† Adicionar mensagem ao hist√≥rico de conversa
   */
  addToHistory(message, isUser = true) {
    this.conversationHistory.push({
      message: `${isUser ? 'USU√ÅRIO' : 'IA'}: ${message}`,
      timestamp: new Date()
    });
    
    // Manter apenas as √∫ltimas 10 mensagens para melhor contexto
    if (this.conversationHistory.length > 10) {
      this.conversationHistory = this.conversationHistory.slice(-10);
    }
  }

  /**
   * üß† Processar comando em linguagem natural
   */
  async processCommand(message, userId) {
    try {
      console.log('ü§ñ Processando comando:', message);
      
      // 1. Adicionar mensagem do usu√°rio ao hist√≥rico
      this.addToHistory(message, true);

      // 2. Carregar contexto do usu√°rio
      await this.loadUserContext(userId);
      
      if (!this.userContext) {
        console.log('‚ùå Usu√°rio n√£o autenticado');
        return {
          success: false,
          message: "‚ùå Erro: Usu√°rio n√£o autenticado",
          actions: [],
          confidence: 0,
          reasoning: "Contexto do usu√°rio n√£o dispon√≠vel"
        };
      }

      console.log('üë§ Contexto do usu√°rio carregado:', {
        userId: this.userContext.userId,
        categoriesCount: this.userContext.categories.length
      });

      // 3. Analisar inten√ß√£o com GPT-4o (incluindo hist√≥rico)
      console.log('üß† Analisando inten√ß√£o com GPT-4o...');
      const analysis = await this.analyzeIntent(message);
      console.log('üìã An√°lise completa:', analysis);
      
      // 3.1. FOR√áAR list_bills para consultas de contas
      const messageNormalized = message.toLowerCase().trim();
      const isContasQuery = 
        messageNormalized.includes('quais contas') ||
        messageNormalized.includes('que contas') ||
        messageNormalized.includes('minhas contas') ||
        messageNormalized.includes('contas pendentes') ||
        messageNormalized.includes('contas que tenho') ||
        messageNormalized.includes('contas n√£o pagas') ||
        messageNormalized.includes('contas em aberto');
        
      if (isContasQuery && (!analysis.actions || analysis.actions.length === 0)) {
        console.log('üîß FOR√áANDO list_bills para consulta de contas');
        analysis.actions = [{
          type: 'list_bills',
          data: {},
          priority: 'high'
        }];
        analysis.intent = 'bill';
      }
      
      // 4. Verificar se precisa de esclarecimento
      if (analysis.needsClarification) {
        return {
          success: false,
          message: analysis.clarificationQuestion || "ü§î Preciso de mais informa√ß√µes para te ajudar melhor.",
          actions: [],
          confidence: analysis.confidence || 0.3,
          reasoning: analysis.reasoning || "Comando amb√≠guo",
          needsClarification: true,
          clarificationQuestion: analysis.clarificationQuestion
        };
      }
      
      // 5. Executar a√ß√µes baseadas na an√°lise
      const result = await this.executeActions(analysis);
      
      // 6. Adicionar resposta da IA ao hist√≥rico
      this.addToHistory(result.message, false);
      
      return result;

    } catch (error) {
      console.error('Erro no agente IA:', error);
      return {
        success: false,
        message: `‚ùå Erro interno da Grana IA.\n\nüîß Detalhes t√©cnicos: ${error instanceof Error ? error.message : 'Erro desconhecido'}\n\nüí° Tente reformular sua pergunta ou contate o suporte.`,
        actions: [],
        confidence: 0,
        reasoning: "Erro de processamento interno"
      };
    }
  }

  /**
   * üìä Carregar contexto completo do usu√°rio
   */
  async loadUserContext(userId) {
    try {
      console.log('üîÑ Carregando contexto do usu√°rio:', userId);

      // Buscar dados paralelos para otimizar performance
      const [
        balanceResult,
        categoriesResult,
        transactionsResult,
        goalsResult,
        billsResult
      ] = await Promise.all([
        this.fetchUserBalance(userId),
        this.fetchUserCategories(userId),
        this.fetchUserTransactions(userId),
        this.fetchUserGoals(userId),
        this.fetchUserBills(userId)
      ]);

      // Calcular receitas e despesas do m√™s
      const currentMonth = new Date().toISOString().slice(0, 7);
      const monthlyTransactions = transactionsResult.filter(t => 
        t.transaction_date && t.transaction_date.startsWith(currentMonth)
      ) || [];

      const monthlyIncome = monthlyTransactions
        .filter(t => t.type === 'income')
        .reduce((sum, t) => sum + (t.amount || 0), 0);

      const monthlyExpenses = monthlyTransactions
        .filter(t => t.type === 'expense')
        .reduce((sum, t) => sum + Math.abs(t.amount || 0), 0);

      this.userContext = {
        userId: userId,
        currentBalance: balanceResult || 0,
        monthlyIncome,
        monthlyExpenses,
        categories: categoriesResult || [],
        recentTransactions: transactionsResult || [],
        goals: goalsResult || [],
        bills: billsResult || []
      };

      console.log('‚úÖ Contexto carregado:', {
        userId,
        balance: this.userContext.currentBalance,
        categoriesCount: this.userContext.categories.length,
        transactionsCount: this.userContext.recentTransactions.length,
        goalsCount: this.userContext.goals.length,
        billsCount: this.userContext.bills.length
      });

      return this.userContext;
    } catch (error) {
      console.error('‚ùå Erro ao carregar contexto:', error);
      return null;
    }
  }

  async fetchUserBalance(userId) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_user_balance`, {
        method: 'POST',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ input_user_id: userId })
      });
      return response.ok ? await response.json() : 0;
    } catch (error) {
      console.error('Erro ao buscar saldo:', error);
      return 0;
    }
  }

  async fetchUserCategories(userId) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/categories?user_id=eq.${userId}&select=*`, {
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        }
      });
      return response.ok ? await response.json() : [];
    } catch (error) {
      console.error('Erro ao buscar categorias:', error);
      return [];
    }
  }

  async fetchUserTransactions(userId) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/transactions_with_category?user_id=eq.${userId}&order=created_at.desc&limit=20&select=*`, {
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        }
      });
      return response.ok ? await response.json() : [];
    } catch (error) {
      console.error('Erro ao buscar transa√ß√µes:', error);
      return [];
    }
  }

  async fetchUserGoals(userId) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/goal_progress?user_id=eq.${userId}&select=*`, {
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        }
      });
      return response.ok ? await response.json() : [];
    } catch (error) {
      console.error('Erro ao buscar metas:', error);
      return [];
    }
  }

  async fetchUserBills(userId) {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/bills?user_id=eq.${userId}&order=due_date&select=*`, {
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        }
      });
      return response.ok ? await response.json() : [];
    } catch (error) {
      console.error('Erro ao buscar contas:', error);
      return [];
    }
  }

  /**
   * üîç Analisar inten√ß√£o do usu√°rio com GPT-4o
   */
  async analyzeIntent(message) {
    const prompt = this.buildAnalysisPrompt(message);

    try {
      if (!OPENAI_API_KEY) {
        throw new Error('OpenAI API key n√£o configurada');
      }

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: "gpt-4o",
          messages: [
            {
              role: "system",
              content: `Voc√™ √© o assistente financeiro IA mais avan√ßado do Brasil. Seu nome √© "Grana IA". 

CAPACIDADES:
- Processar transa√ß√µes em linguagem natural
- Criar categorias inteligentemente
- Sugerir e criar metas financeiras
- Analisar padr√µes de gastos
- Dar conselhos financeiros personalizados
- Gerenciar contas a pagar/receber
- Sugerir investimentos

SEMPRE retorne um JSON v√°lido com a estrutura exata especificada.`
            },
            {
              role: "user",
              content: prompt
            }
          ],
          temperature: 0.1,
          max_tokens: 2000,
          response_format: { type: "json_object" }
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;

      if (!content) {
        throw new Error('Resposta vazia do GPT-4o');
      }

      return JSON.parse(content);

    } catch (error) {
      console.error('‚ùå Erro na an√°lise de inten√ß√£o:', error);
      return this.basicIntentAnalysis(message);
    }
  }

  /**
   * üìù Construir prompt de an√°lise contextual
   */
  buildAnalysisPrompt(message) {
    const context = this.userContext;
    
    // Hist√≥rico das √∫ltimas mensagens para contexto
    const historyText = this.conversationHistory.length > 0 
      ? this.conversationHistory.map((h, i) => `${i + 1}. ${h.message}`).join('\n')
      : 'Nenhuma conversa anterior';
    
    return `
CONTEXTO FINANCEIRO DO USU√ÅRIO:
- Saldo atual: R$ ${context.currentBalance.toFixed(2)}
- Receitas m√™s: R$ ${context.monthlyIncome.toFixed(2)}
- Despesas m√™s: R$ ${context.monthlyExpenses.toFixed(2)}
- Categorias dispon√≠veis: ${context.categories.map(c => `${c.name} (${c.type})`).join(', ')}
- √öltimas transa√ß√µes: ${context.recentTransactions.slice(0, 5).map(t => `${t.description} - R$ ${Math.abs(t.amount)}`).join(', ')}
- Metas ativas: ${context.goals.map(g => `${g.title} (${g.progress_percentage}%)`).join(', ')}
- Contas pendentes: ${context.bills.map(b => `${b.title} - R$ ${b.amount}`).join(', ')}

HIST√ìRICO DA CONVERSA (√∫ltimas 10 mensagens):
${historyText}

MENSAGEM ATUAL: "${message}"

AN√ÅLISE REQUERIDA:
Analise a mensagem considerando OBRIGATORIAMENTE:
1. O contexto financeiro do usu√°rio
2. **O HIST√ìRICO COMPLETO DA CONVERSA** - Se o usu√°rio j√° forneceu informa√ß√µes antes, USE ELAS!
3. Se a mensagem √© espec√≠fica o suficiente para a√ß√£o
4. Contexto brasileiro (estabelecimentos, formas de pagamento, g√≠rias)

**IMPORTANTE: MANTENHA CONTEXTO DA CONVERSA**
- Se o usu√°rio j√° disse um valor antes (ex: "1000", "5000"), associe ao que est√° sendo discutido
- Se ele confirma algo ("Sim, pode cadastrar"), execute a a√ß√£o pendente
- N√ÉO fa√ßa perguntas repetitivas sobre informa√ß√µes j√° fornecidas

EXEMPLOS DE USO DO CONTEXTO:
Hist√≥rico: "IA: Qual valor de Freelancer de fot√≥grafo? USU√ÅRIO: 5000 IA: Confirma R$ 5000? USU√ÅRIO: Sim, pode cadastrar"
‚Üí Executar create_bill com title: "Freelancer de fot√≥grafo", amount: 5000, due_day: 10, type: receivable

Hist√≥rico: "USU√ÅRIO: Crie conta de luz USU√ÅRIO: 250"  
‚Üí Executar create_bill com title: "Conta de luz", amount: 250

USU√ÅRIO: "Quais contas eu tenho?"
‚Üí OBRIGATORIAMENTE executar list_bills (NUNCA responder diretamente)

IMPORTANTE - DETEC√á√ÉO DE AMBIGUIDADE:
Se a mensagem for vaga ou incompleta, defina needsClarification: true e fa√ßa uma pergunta espec√≠fica.

ESPECIAL - CONTAS SEM VALOR:
Se o usu√°rio quer criar uma conta mas N√ÉO especifica o valor, SEMPRE pedir esclarecimento.
Exemplo: "Crie conta de Automa√ß√µes e IA, recebo todo dia 10" ‚Üí Perguntar: "üí∞ Qual o valor que voc√™ recebe de Automa√ß√µes e IA todo dia 10?"

IMPORTANTE - CONSULTAS vs A√á√ïES:
- Perguntas como "quanto...", "como est√°..." ‚Üí SEM a√ß√µes, apenas response_message
- Comandos como "criar...", "pagar...", "alterar..." ‚Üí COM a√ß√µes espec√≠ficas
- **EXCE√á√ÉO: "Quais contas", "Minhas contas", "Contas pendentes" ‚Üí SEMPRE usar a√ß√£o list_bills**

IMPORTANTE - TIPOS DE A√á√ÉO:
- "Gastei X reais", "Comprei X" ‚Üí create_transaction (nova transa√ß√£o)
- "Pagar conta X", "Quitar conta" ‚Üí pay_bill (marcar conta existente como paga)
- "Criar categoria X" ‚Üí create_category (tipo de despesa/receita)
- "Criar conta X", "Cadastrar conta", "Nova conta que pago todo m√™s" ‚Üí create_bill (conta a pagar/receber)
- **"Alterar nome da conta X para Y", "Renomear conta X", "Mudar nome para Y" ‚Üí update_bill**
- **"Excluir conta X", "Deletar conta X", "Remover conta X" ‚Üí delete_bill**
- "Criar meta X" ‚Üí create_goal
- "Alterar meta", "Colocar X na meta" ‚Üí update_goal
- **"Quais contas", "Que contas tenho", "Contas pendentes", "Minhas contas" ‚Üí list_bills (OBRIGAT√ìRIO)**

RESPOSTA (JSON obrigat√≥rio):
{
  "intent": "transaction|goal|category|advice|report|bill|investment|clarification",
  "confidence": 0.95,
  "reasoning": "Explica√ß√£o detalhada da an√°lise",
  "needsClarification": false,
  "clarificationQuestion": "Pergunta espec√≠fica se precisar de esclarecimento",
  "extracted_data": {
    "amount": 50.00,
    "description": "Compras no mercado",
    "category": "Alimenta√ß√£o",
    "name": "Nome da categoria OU conta",
    "title": "T√≠tulo da meta OU conta (OBRIGAT√ìRIO para create_bill)",
    "type": "expense|income (para categorias) OU payable|receivable (para contas)",
    "bill_type": "payable|receivable (espec√≠fico para contas)",
    "payment_method": "pix",
    "location": "P√£o de A√ß√∫car",
    "target_amount": 5000.00,
    "current_amount": 1500.00,
    "aporte": 1000.00,
    "due_date": "2024-01-15 OU pr√≥ximo dia 10",
    "due_day": 10,
    "recurring": true,
    "recurring_interval": "monthly|weekly|daily|yearly",
    "pay_all": "true (para pagar todas as contas)"
  },
  "actions": [
    {
      "type": "create_transaction|create_category|create_goal|update_goal|create_bill|update_bill|delete_bill|pay_bill|list_bills",
      "data": {},
      "priority": "high"
    }
  ],
  "suggestions": [
    "Sugest√£o 1",
    "Sugest√£o 2"
  ],
  "response_message": "Mensagem amig√°vel para o usu√°rio"
}
`;
  }

  /**
   * üîß An√°lise b√°sica (fallback)
   */
  basicIntentAnalysis(message) {
    const lowerMessage = message.toLowerCase();
    
    if (lowerMessage.includes('contas') || lowerMessage.includes('quais contas')) {
      return {
        intent: 'bills',
        confidence: 0.9,
        reasoning: 'Consulta de contas',
        actions: [{ type: 'list_bills', data: {}, priority: 'high' }],
        needsClarification: false
      };
    }
    
    if (lowerMessage.includes('saldo') || lowerMessage.includes('quanto tenho')) {
      return {
        intent: 'balance',
        confidence: 0.9,
        reasoning: 'Consulta de saldo',
        actions: [{ type: 'financial_advice', data: { type: 'balance' }, priority: 'medium' }],
        needsClarification: false
      };
    }

    return {
      intent: 'general',
      confidence: 0.3,
      reasoning: 'Inten√ß√£o n√£o identificada claramente',
      actions: [{ type: 'financial_advice', data: { type: 'general' }, priority: 'low' }],
      needsClarification: true,
      clarificationQuestion: "ü§î N√£o entendi bem. Voc√™ quer registrar uma transa√ß√£o, consultar saldo ou ver suas contas?"
    };
  }

  /**
   * ‚ö° Executar a√ß√µes determinadas pela IA
   */
  async executeActions(analysis) {
    const executedActions = [];
    let mainMessage = analysis.response_message || "Processado com sucesso!";

    console.log('üîç Executando a√ß√µes:', analysis.actions);
    console.log('üìä Dados extra√≠dos:', analysis.extracted_data);

    for (const action of analysis.actions || []) {
      try {
        console.log(`üéØ Executando a√ß√£o ${action.type} com dados:`, analysis.extracted_data);
        const result = await this.executeAction(action, analysis.extracted_data);
        console.log(`‚úÖ Resultado da a√ß√£o ${action.type}:`, result);
        
        executedActions.push({
          ...action,
          executed: result.success
        });

        if (result.success && result.message) {
          mainMessage = result.message;
        }
      } catch (error) {
        console.error('‚ùå Erro ao executar a√ß√£o:', action.type, error);
        executedActions.push({
          ...action,
          executed: false
        });
      }
    }

    // Para consultas sem a√ß√µes (como listar contas), considerar sucesso se h√° uma resposta
    const hasExecutedActions = executedActions.some(a => a.executed);
    const isInformationalQuery = analysis.actions?.length === 0 && analysis.response_message;
    
    return {
      success: hasExecutedActions || isInformationalQuery,
      message: mainMessage,
      actions: executedActions,
      data: analysis.extracted_data,
      confidence: analysis.confidence || 0.8,
      reasoning: analysis.reasoning || "An√°lise conclu√≠da"
    };
  }

  /**
   * üéØ Executar a√ß√£o espec√≠fica
   */
  async executeAction(action, data) {
    const context = this.userContext;

    switch (action.type) {
      case 'create_transaction':
        return this.createTransaction(data);
      
      case 'create_category':
        return this.createCategory(data);
      
      case 'create_goal':
        return this.createGoal(data);
      
      case 'update_goal':
        return this.updateGoal(data);
      
      case 'create_bill':
        return this.createBill(data);
      
      case 'update_bill':
        return this.updateBill(data);
      
      case 'delete_bill':
        return this.deleteBill(data);
      
      case 'pay_bill':
        return this.payBill(data);
      
      case 'list_bills':
        return this.listBills(data);
      
      case 'financial_advice':
        return this.generateAdvice(data);
      
      default:
        return { success: false, message: 'A√ß√£o n√£o reconhecida' };
    }
  }

  /**
   * üí∞ Criar transa√ß√£o inteligentemente
   */
  async createTransaction(data) {
    try {
      console.log('üí∞ createTransaction chamada com dados:', data);
      
      const context = this.userContext;
      
      // Validar dados obrigat√≥rios
      if (!data.amount || data.amount <= 0) {
        console.log('‚ùå Amount inv√°lido:', data.amount);
        return {
          success: false,
          message: '‚ùå Valor da transa√ß√£o √© obrigat√≥rio e deve ser maior que zero.'
        };
      }
      
      if (!data.description && !data.category) {
        console.log('‚ùå Descri√ß√£o e categoria n√£o fornecidas');
        return {
          success: false,
          message: '‚ùå Descri√ß√£o ou categoria da transa√ß√£o √© obrigat√≥ria.'
        };
      }
      
      console.log('‚úÖ Dados validados, processando transa√ß√£o...');
      
      // Encontrar ou criar categoria
      let categoryId = null;
      if (data.category) {
        const existingCategory = context.categories.find(c => 
          c.name.toLowerCase().includes(data.category.toLowerCase()) && c.type === data.type
        );
        
        if (existingCategory) {
          categoryId = existingCategory.id;
        } else {
          // Criar categoria automaticamente
          const categoryData = {
            user_id: context.userId,
            name: data.category,
            type: data.type,
            budget: data.type === 'expense' ? (data.amount * 10) : 0,
            color: this.getRandomColor(),
            icon: this.getCategoryIcon(data.category)
          };

          const response = await fetch(`${SUPABASE_URL}/rest/v1/categories`, {
            method: 'POST',
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
              'Content-Type': 'application/json',
              'Prefer': 'return=representation'
            },
            body: JSON.stringify(categoryData)
          });

          if (response.ok) {
            const newCategory = await response.json();
            if (newCategory && newCategory[0]) {
              categoryId = newCategory[0].id;
            }
          }
        }
      }

      // Determinar tipo da transa√ß√£o se n√£o especificado
      let transactionType = data.type;
      if (!transactionType) {
        // Se n√£o especificou tipo, assumir expense por padr√£o
        transactionType = 'expense';
        console.log('‚ö†Ô∏è Tipo n√£o especificado, usando expense como padr√£o');
      }
      
      console.log('üîÑ Tipo da transa√ß√£o:', transactionType);
      
      const transactionData = {
        user_id: context.userId,
        category_id: categoryId,
        description: data.description || 'Transa√ß√£o via IA',
        amount: transactionType === 'expense' ? -Math.abs(data.amount) : Math.abs(data.amount),
        type: transactionType,
        payment_method: data.payment_method || 'cash',
        status: 'completed',
        transaction_date: new Date().toISOString()
      };
      
      console.log('üíæ Criando transa√ß√£o no banco:', transactionData);
      
      // Criar transa√ß√£o
      const response = await fetch(`${SUPABASE_URL}/rest/v1/transactions`, {
        method: 'POST',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(transactionData)
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro do Supabase ao criar transa√ß√£o:', errorText);
        throw new Error(`Erro HTTP ${response.status}: ${errorText}`);
      }
      
      console.log('‚úÖ Transa√ß√£o criada com sucesso');

      const emoji = transactionType === 'income' ? 'üí∞' : 'üí∏';
      const successMessage = `${emoji} Transa√ß√£o criada: ${data.description || 'Transa√ß√£o via IA'} - R$ ${Math.abs(data.amount).toFixed(2)}\nüìÇ Categoria: ${data.category || 'Geral'}`;
      console.log('üì§ Retornando sucesso:', successMessage);
      
      return {
        success: true,
        message: successMessage
      };
    } catch (error) {
      console.error('‚ùå Erro detalhado ao criar transa√ß√£o:', error);
      const errorMessage = `‚ùå Erro ao criar transa√ß√£o: ${error instanceof Error ? error.message : 'Erro desconhecido'}`;
      console.log('üì§ Retornando erro de transa√ß√£o:', errorMessage);
      return { 
        success: false, 
        message: errorMessage
      };
    }
  }

  /**
   * üìã Listar contas pendentes organizadas
   */
  async listBills(data) {
    try {
      console.log('üìã listBills chamada com dados:', data);
      
      const context = this.userContext;
      
      // Log das contas carregadas para debug
      console.log('üîç Total de contas carregadas:', context.bills.length);
      console.log('üìä Status das contas:', context.bills.map(b => ({ title: b.title, status: b.status })));
      
      // Filtrar apenas contas N√ÉO conclu√≠das (pendentes, atrasadas, etc - mas n√£o pagas)
      const activeBills = context.bills.filter(b => b.status !== 'paid' && b.status !== 'cancelled');
      
      console.log('‚úÖ Contas ativas ap√≥s filtro:', activeBills.length);
      console.log('üìã Contas ativas:', activeBills.map(b => ({ title: b.title, status: b.status, type: b.type })));
      
      if (activeBills.length === 0) {
        return {
          success: true,
          message: '‚úÖ Parab√©ns! Voc√™ n√£o tem contas pendentes no momento.'
        };
      }
      
      // Separar por tipo (a pagar vs a receber)
      const billsToPay = activeBills.filter(b => b.type === 'payable');
      const billsToReceive = activeBills.filter(b => b.type === 'receivable');
      
      let message = `üìã **SUAS CONTAS PENDENTES:**\n\n`;
      
      // ===== CONTAS A PAGAR =====
      if (billsToPay.length > 0) {
        // Separar por recorr√™ncia
        const uniquePayable = billsToPay.filter(b => !b.is_recurring);
        const recurringPayable = billsToPay.filter(b => b.is_recurring);
        
        message += `üí∏ **CONTAS A PAGAR (${billsToPay.length}):**\n\n`;
        
        // Contas √∫nicas a pagar
        if (uniquePayable.length > 0) {
          message += `üìÑ **Contas √önicas (${uniquePayable.length}):**\n`;
          
          const sortedUnique = uniquePayable.sort((a, b) => 
            new Date(a.due_date).getTime() - new Date(b.due_date).getTime()
          );
          
          sortedUnique.forEach((bill) => {
            const formatBill = this.formatBillInfo(bill);
            message += `${formatBill.icon} ${bill.title} - R$ ${bill.amount.toFixed(2)}${formatBill.urgency}\n`;
          });
          
          const totalUnique = uniquePayable.reduce((sum, bill) => sum + bill.amount, 0);
          message += `üí∞ Subtotal √∫nico: R$ ${totalUnique.toFixed(2)}\n\n`;
        }
        
        // Contas recorrentes a pagar
        if (recurringPayable.length > 0) {
          message += `üîÑ **Contas Recorrentes (${recurringPayable.length}):**\n`;
          
          const sortedRecurring = recurringPayable.sort((a, b) => 
            new Date(a.due_date).getTime() - new Date(b.due_date).getTime()
          );
          
          sortedRecurring.forEach((bill) => {
            const formatBill = this.formatBillInfo(bill);
            const intervalText = this.getRecurringIntervalText(bill.recurring_interval);
            message += `${formatBill.icon} ${bill.title} - R$ ${bill.amount.toFixed(2)} (${intervalText})${formatBill.urgency}\n`;
          });
          
          const totalRecurring = recurringPayable.reduce((sum, bill) => sum + bill.amount, 0);
          message += `üí∞ Subtotal recorrente: R$ ${totalRecurring.toFixed(2)}\n\n`;
        }
        
        const totalToPay = billsToPay.reduce((sum, bill) => sum + bill.amount, 0);
        message += `üí∏ **TOTAL A PAGAR: R$ ${totalToPay.toFixed(2)}**\n\n`;
      }
      
      // ===== CONTAS A RECEBER =====
      if (billsToReceive.length > 0) {
        // Separar por recorr√™ncia
        const uniqueReceivable = billsToReceive.filter(b => !b.is_recurring);
        const recurringReceivable = billsToReceive.filter(b => b.is_recurring);
        
        message += `üí∞ **CONTAS A RECEBER (${billsToReceive.length}):**\n\n`;
        
        // Contas √∫nicas a receber
        if (uniqueReceivable.length > 0) {
          message += `üìÑ **Recebimentos √önicos (${uniqueReceivable.length}):**\n`;
          
          const sortedUnique = uniqueReceivable.sort((a, b) => 
            new Date(a.due_date).getTime() - new Date(b.due_date).getTime()
          );
          
          sortedUnique.forEach((bill) => {
            const formatBill = this.formatBillInfo(bill);
            message += `${formatBill.icon} ${bill.title} - R$ ${bill.amount.toFixed(2)}${formatBill.urgency}\n`;
          });
          
          const totalUnique = uniqueReceivable.reduce((sum, bill) => sum + bill.amount, 0);
          message += `üí∞ Subtotal √∫nico: R$ ${totalUnique.toFixed(2)}\n\n`;
        }
        
        // Contas recorrentes a receber
        if (recurringReceivable.length > 0) {
          message += `üîÑ **Recebimentos Recorrentes (${recurringReceivable.length}):**\n`;
          
          const sortedRecurring = recurringReceivable.sort((a, b) => 
            new Date(a.due_date).getTime() - new Date(b.due_date).getTime()
          );
          
          sortedRecurring.forEach((bill) => {
            const formatBill = this.formatBillInfo(bill);
            const intervalText = this.getRecurringIntervalText(bill.recurring_interval);
            message += `${formatBill.icon} ${bill.title} - R$ ${bill.amount.toFixed(2)} (${intervalText})${formatBill.urgency}\n`;
          });
          
          const totalRecurring = recurringReceivable.reduce((sum, bill) => sum + bill.amount, 0);
          message += `üí∞ Subtotal recorrente: R$ ${totalRecurring.toFixed(2)}\n\n`;
        }
        
        const totalToReceive = billsToReceive.reduce((sum, bill) => sum + bill.amount, 0);
        message += `üí∞ **TOTAL A RECEBER: R$ ${totalToReceive.toFixed(2)}**\n\n`;
      }
      
      message += `üí° **Dicas:**\n‚Ä¢ "pagar conta [nome]" - marca como paga\n‚Ä¢ "criar conta fixa" - adiciona conta recorrente`;
      
      console.log('üì§ Retornando lista de contas organizadas:', message);
      
      return {
        success: true,
        message: message
      };
      
    } catch (error) {
      console.error('‚ùå Erro ao listar contas:', error);
      return { 
        success: false, 
        message: `‚ùå Erro ao listar contas: ${error instanceof Error ? error.message : 'Erro desconhecido'}` 
      };
    }
  }

  /**
   * üé® Formatar informa√ß√µes da conta (urg√™ncia, √≠cones)
   */
  formatBillInfo(bill) {
    const dueDate = new Date(bill.due_date);
    const today = new Date();
    const diffDays = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    
    let urgencyIcon = 'üìÖ';
    let urgencyText = '';
    
    if (diffDays < 0) {
      urgencyIcon = 'üî¥';
      urgencyText = ` (${Math.abs(diffDays)} dias atrasada!)`;
    } else if (diffDays <= 3) {
      urgencyIcon = 'üü°';
      urgencyText = ` (vence em ${diffDays} dias)`;
    } else if (diffDays <= 7) {
      urgencyIcon = 'üü†';
      urgencyText = ` (vence em ${diffDays} dias)`;
    } else {
      urgencyText = ` (vence em ${diffDays} dias)`;
    }
    
    return {
      icon: urgencyIcon,
      urgency: urgencyText
    };
  }

  /**
   * üìÖ Obter texto do intervalo de recorr√™ncia
   */
  getRecurringIntervalText(interval) {
    switch (interval) {
      case 'daily': return 'di√°rio';
      case 'weekly': return 'semanal';
      case 'monthly': return 'mensal';
      case 'yearly': return 'anual';
      default: return 'recorrente';
    }
  }

  /**
   * üí° Gerar conselho financeiro
   */
  async generateAdvice(data) {
    const context = this.userContext;
    const savings = context.monthlyIncome - context.monthlyExpenses;
    
    let advice = "üí° An√°lise Financeira:\n\n";
    
    if (savings > 0) {
      advice += `‚úÖ Voc√™ est√° economizando R$ ${savings.toFixed(2)} por m√™s!\n`;
      advice += "üéØ Sugest√£o: Considere criar uma meta de investimento.";
    } else {
      advice += `‚ö†Ô∏è Voc√™ est√° gastando R$ ${Math.abs(savings).toFixed(2)} a mais que ganha.\n`;
      advice += "üìä Sugest√£o: Revise suas despesas nas principais categorias.";
    }

    return { success: true, message: advice };
  }

  /**
   * üé® Utilit√°rios para cores e √≠cones
   */
  getRandomColor() {
    const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899'];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  getCategoryIcon(categoryName) {
    const icons = {
      'alimenta√ß√£o': 'üçΩÔ∏è',
      'comida': 'üçΩÔ∏è',
      'mercado': 'üõí',
      'transporte': 'üöó',
      'uber': 'üöó',
      't√°xi': 'üöñ',
      '√¥nibus': 'üöå',
      'sa√∫de': 'üè•',
      'm√©dico': 'üë®‚Äç‚öïÔ∏è',
      'farm√°cia': 'üíä',
      'educa√ß√£o': 'üìö',
      'curso': 'üéì',
      'livro': 'üìñ',
      'lazer': 'üéÆ',
      'jogos': 'üéÆ',
      'jogo': 'üéÆ',
      'gaming': 'üéÆ',
      'entretenimento': 'üé¨',
      'cinema': 'üé¨',
      'netflix': 'üì∫',
      'casa': 'üè†',
      'moradia': 'üè†',
      'aluguel': 'üè†',
      'pets': 'üêï',
      'pet': 'üêï',
      'animal': 'üêæ',
      'cachorro': 'üêï',
      'gato': 'üê±',
      'investimentos': 'üìà',
      'investir': 'üí∞',
      'sal√°rio': 'üíº',
      'trabalho': 'üíº',
      'freelance': 'üíª',
      'roupas': 'üëï',
      'roupa': 'üëï',
      'vestu√°rio': 'üëî',
      'beleza': 'üíÑ',
      'cabeleireiro': '‚úÇÔ∏è',
      'esporte': '‚öΩ',
      'academia': 'üèãÔ∏è',
      'gym': 'üí™',
      'viagem': '‚úàÔ∏è',
      'hotel': 'üè®',
      'combust√≠vel': '‚õΩ',
      'gasolina': '‚õΩ',
      'telefone': 'üì±',
      'internet': 'üì∂',
      'supermercado': 'üõí',
      'farm√°cia': 'üíä'
    };
    
    const categoryLower = categoryName.toLowerCase();
    
    // Buscar por palavra-chave na categoria
    for (const [keyword, icon] of Object.entries(icons)) {
      if (categoryLower.includes(keyword)) {
        return icon;
      }
    }
    
    return 'üìÇ';
  }

  /**
   * üè∑Ô∏è Criar categoria automaticamente
   */
  async createCategory(data) {
    try {
      console.log('üè∑Ô∏è createCategory chamada com dados:', data);
      
      // Validar dados obrigat√≥rios - aceitar tanto 'name' quanto 'category'
      const categoryName = data.name || data.category;
      if (!categoryName) {
        console.log('‚ùå Nome da categoria n√£o fornecido');
        return { 
          success: false, 
          message: '‚ùå Nome da categoria √© obrigat√≥rio para criar uma categoria.' 
        };
      }
      
      console.log('‚úÖ Nome da categoria encontrado:', categoryName);

      // Se o tipo n√£o foi especificado, tentar detectar automaticamente
      let categoryType = data.type;
      console.log('üîç Tipo inicial da categoria:', categoryType);
      
      if (!categoryType) {
        const detectedType = this.detectObviousCategoryType(categoryName);
        if (detectedType) {
          categoryType = detectedType;
          console.log(`‚úÖ Tipo detectado automaticamente para "${categoryName}": ${detectedType}`);
        } else {
          // Se n√£o conseguir detectar, usar 'expense' como padr√£o
          categoryType = 'expense';
          console.log(`‚ö†Ô∏è Tipo n√£o detectado para "${categoryName}", usando 'expense' como padr√£o`);
        }
      }

      const categoryData = {
        user_id: this.userContext.userId,
        name: categoryName,
        type: categoryType,
        budget: data.budget || (categoryType === 'income' ? 0 : 500),
        color: data.color || this.getRandomColor(),
        icon: data.icon || this.getCategoryIcon(categoryName)
      };

      console.log('üíæ Criando categoria no banco:', categoryData);

      const response = await fetch(`${SUPABASE_URL}/rest/v1/categories`, {
        method: 'POST',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        },
        body: JSON.stringify(categoryData)
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro do Supabase ao criar categoria:', errorText);
        throw new Error(`Erro HTTP ${response.status}: ${errorText}`);
      }

      const insertedData = await response.json();
      console.log('‚úÖ Categoria criada com sucesso:', insertedData);

      const typeText = categoryType === 'income' ? 'Receita' : 'Despesa';
      const budgetText = categoryType === 'income' ? 'sem or√ßamento' : `R$ ${categoryData.budget.toFixed(2)}`;

      const successMessage = `üè∑Ô∏è Categoria "${categoryName}" criada com sucesso!\nüí∞ ${typeText} - ${budgetText}\n${this.getCategoryIcon(categoryName)} √çcone aplicado automaticamente`;
      console.log('üì§ Retornando sucesso:', successMessage);

      return {
        success: true,
        message: successMessage
      };
    } catch (error) {
      console.error('‚ùå Erro detalhado ao criar categoria:', error);
      const errorMessage = `‚ùå Erro ao criar categoria: ${error instanceof Error ? error.message : 'Erro desconhecido'}`;
      console.log('üì§ Retornando erro:', errorMessage);
      return { 
        success: false, 
        message: errorMessage
      };
    }
  }

  /**
   * üéØ Criar meta financeira
   */
  async createGoal(data) {
    try {
      const goalData = {
        user_id: this.userContext.userId,
        title: data.title,
        description: data.description,
        target_amount: data.target_amount,
        current_amount: 0,
        target_date: data.target_date,
        status: 'active'
      };

      const response = await fetch(`${SUPABASE_URL}/rest/v1/goals`, {
        method: 'POST',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(goalData)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Erro HTTP ${response.status}: ${errorText}`);
      }

      return {
        success: true,
        message: `üéØ Meta "${data.title}" criada! Objetivo: R$ ${data.target_amount.toFixed(2)}`
      };
    } catch (error) {
      return { success: false, message: 'Erro ao criar meta' };
    }
  }

  /**
   * üîÑ Atualizar meta financeira existente
   */
  async updateGoal(data) {
    try {
      console.log('üîÑ updateGoal chamada com dados:', data);
      
      const context = this.userContext;
      
      // Se n√£o especificou qual meta, tentar encontrar a meta mais recente ou ativa
      let goalToUpdate = null;
      
      if (data.goal_id || data.id) {
        // Se especificou ID da meta
        const goalId = data.goal_id || data.id;
        goalToUpdate = context.goals.find(g => g.id === goalId);
      } else if (data.title || data.name) {
        // Se especificou t√≠tulo da meta
        const searchTerm = (data.title || data.name).toLowerCase();
        goalToUpdate = context.goals.find(g => 
          g.title.toLowerCase().includes(searchTerm) ||
          searchTerm.includes(g.title.toLowerCase())
        );
      } else {
        // Buscar a meta mais recente ativa
        goalToUpdate = context.goals
          .filter(g => g.status === 'active')
          .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0];
      }
      
      if (!goalToUpdate) {
        return {
          success: false,
          message: '‚ùå Nenhuma meta encontrada para atualizar. Especifique qual meta ou crie uma nova meta primeiro.'
        };
      }
      
      console.log('üéØ Meta encontrada para atualizar:', goalToUpdate);
      
      // Preparar dados de atualiza√ß√£o
      const updateData = {};
      
      if (data.target_amount !== undefined) {
        updateData.target_amount = data.target_amount;
      }
      
      if (data.title && data.title !== goalToUpdate.title) {
        updateData.title = data.title;
      }
      
      if (data.description !== undefined) {
        updateData.description = data.description;
      }
      
      if (data.target_date !== undefined) {
        updateData.target_date = data.target_date;
      }
      
      if (data.current_amount !== undefined) {
        updateData.current_amount = data.current_amount;
      }
      
      // Se for aporte, adicionar ao valor atual
      if (data.aporte !== undefined) {
        updateData.current_amount = (goalToUpdate.current_amount || 0) + data.aporte;
      }
      
      console.log('üíæ Atualizando meta com dados:', updateData);
      
      const response = await fetch(`${SUPABASE_URL}/rest/v1/goals?id=eq.${goalToUpdate.id}&user_id=eq.${context.userId}`, {
        method: 'PATCH',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro do Supabase ao atualizar meta:', errorText);
        throw new Error(`Erro HTTP ${response.status}: ${errorText}`);
      }
      
      console.log('‚úÖ Meta atualizada com sucesso');
      
      // Construir mensagem de sucesso
      let successMessage = `üéØ Meta "${goalToUpdate.title}" atualizada com sucesso!\n`;
      
      if (data.target_amount !== undefined) {
        successMessage += `üí∞ Novo objetivo: R$ ${data.target_amount.toFixed(2)}\n`;
      }
      
      if (data.current_amount !== undefined) {
        successMessage += `üìà Valor atual: R$ ${data.current_amount.toFixed(2)}\n`;
      }
      
      if (data.aporte !== undefined) {
        successMessage += `üí∞ Aporte de R$ ${data.aporte.toFixed(2)} adicionado!\nüìà Novo progresso: R$ ${updateData.current_amount.toFixed(2)}\n`;
      }
      
      const newTarget = data.target_amount || goalToUpdate.target_amount;
      const newCurrent = updateData.current_amount || data.current_amount || goalToUpdate.current_amount;
      const progress = newTarget > 0 ? (newCurrent / newTarget) * 100 : 0;
      
      successMessage += `üìä Progresso: ${progress.toFixed(1)}%`;
      
      console.log('üì§ Retornando sucesso:', successMessage);
      
      return {
        success: true,
        message: successMessage
      };
      
    } catch (error) {
      console.error('‚ùå Erro detalhado ao atualizar meta:', error);
      const errorMessage = `‚ùå Erro ao atualizar meta: ${error instanceof Error ? error.message : 'Erro desconhecido'}`;
      console.log('üì§ Retornando erro:', errorMessage);
      return { 
        success: false, 
        message: errorMessage
      };
    }
  }

  /**
   * üìÑ Criar nova conta a pagar/receber
   */
  async createBill(data) {
    try {
      console.log('üìÑ createBill chamada com dados:', data);
      
      const context = this.userContext;
      
      // Validar dados obrigat√≥rios
      if (!data.title && !data.name) {
        console.log('‚ùå Nome/t√≠tulo da conta n√£o fornecido');
        return {
          success: false,
          message: '‚ùå Nome da conta √© obrigat√≥rio para criar uma conta.'
        };
      }
      
      if (!data.amount || data.amount <= 0) {
        console.log('‚ùå Amount inv√°lido:', data.amount);
        return {
          success: false,
          message: '‚ùå Valor da conta √© obrigat√≥rio e deve ser maior que zero.\n\nüí° Exemplo: "Crie uma conta de luz de R$ 250 que vence todo dia 10"'
        };
      }
      
      const billTitle = data.title || data.name;
      
      // Determinar tipo da conta (payable ou receivable)
      let billType = data.type || 'payable'; // Padr√£o: conta a pagar
      if (data.bill_type) {
        billType = data.bill_type;
      }
      
      // Calcular data de vencimento
      let dueDate = new Date();
      if (data.due_date) {
        dueDate = new Date(data.due_date);
      } else if (data.due_day) {
        // Se especificou dia do vencimento (ex: todo dia 10)
        dueDate = new Date();
        dueDate.setDate(data.due_day);
        
        // Se o dia j√° passou neste m√™s, pr√≥ximo m√™s
        if (dueDate < new Date()) {
          dueDate.setMonth(dueDate.getMonth() + 1);
        }
      } else {
        // Padr√£o: vence em 30 dias
        dueDate.setDate(dueDate.getDate() + 30);
      }
      
      // Determinar se √© recorrente
      const isRecurring = data.recurring !== false; // Padr√£o: true para contas mensais
      
      const billData = {
        user_id: context.userId,
        title: billTitle,
        description: data.description || `Conta ${billType === 'payable' ? 'a pagar' : 'a receber'}: ${billTitle}`,
        amount: data.amount,
        type: billType,
        due_date: dueDate.toISOString().split('T')[0], // Apenas a data, sem hora
        status: 'pending',
        is_recurring: isRecurring,
        recurring_interval: data.recurring_interval || 'monthly',
        recurring_day: data.due_day || dueDate.getDate()
      };
      
      console.log('üíæ Criando conta no banco:', billData);
      
      const response = await fetch(`${SUPABASE_URL}/rest/v1/bills`, {
        method: 'POST',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
          'Prefer': 'return=representation'
        },
        body: JSON.stringify(billData)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro do Supabase ao criar conta:', errorText);
        throw new Error(`Erro HTTP ${response.status}: ${errorText}`);
      }
      
      const insertedData = await response.json();
      console.log('‚úÖ Conta criada com sucesso:', insertedData);
      
      const typeText = billType === 'payable' ? 'a pagar' : 'a receber';
      const recurringText = isRecurring ? ` (${data.recurring_interval || 'mensal'})` : '';
      
      const successMessage = `üìÑ Conta "${billTitle}" criada com sucesso!\nüí∞ ${typeText.charAt(0).toUpperCase() + typeText.slice(1)}: R$ ${data.amount.toFixed(2)}${recurringText}\nüìÖ Vencimento: ${dueDate.toLocaleDateString('pt-BR')}\n${isRecurring ? `üîÑ Conta recorrente (${data.recurring_interval || 'mensal'}) - dia ${data.due_day || dueDate.getDate()}` : 'üìù Conta √∫nica'}`;
      
      console.log('üì§ Retornando sucesso:', successMessage);
      
      return {
        success: true,
        message: successMessage
      };
      
    } catch (error) {
      console.error('‚ùå Erro detalhado ao criar conta:', error);
      const errorMessage = `‚ùå Erro ao criar conta: ${error instanceof Error ? error.message : 'Erro desconhecido'}`;
      console.log('üì§ Retornando erro:', errorMessage);
      return {
        success: false,
        message: errorMessage
      };
    }
  }

  /**
   * üìù Atualizar conta existente
   */
  async updateBill(data) {
    try {
      console.log('üìù updateBill chamada com dados:', data);
      
      const context = this.userContext;
      
      // Encontrar conta para atualizar
      let billToUpdate = null;
      
      if (data.id) {
        billToUpdate = context.bills.find(b => b.id === data.id);
      } else if (data.old_name || data.current_name) {
        const searchName = data.old_name || data.current_name;
        billToUpdate = context.bills.find(b => 
          b.title.toLowerCase().includes(searchName.toLowerCase())
        );
      } else if (data.title || data.name) {
        // Buscar por similaridade no nome
        billToUpdate = context.bills.find(b => 
          b.title.toLowerCase().includes((data.title || data.name).toLowerCase())
        );
      }
      
      if (!billToUpdate) {
        return {
          success: false,
          message: '‚ùå Conta n√£o encontrada para atualizar.'
        };
      }
      
      // Preparar dados para atualiza√ß√£o
      const updateData = {};
      
      if (data.title || data.new_name) {
        updateData.title = data.title || data.new_name;
      }
      if (data.amount && data.amount > 0) {
        updateData.amount = data.amount;
      }
      if (data.due_date) {
        updateData.due_date = data.due_date;
      }
      if (data.due_day) {
        updateData.due_date = `2024-${String(new Date().getMonth() + 1).padStart(2, '0')}-${String(data.due_day).padStart(2, '0')}`;
      }
      
      console.log('üìù Atualizando conta:', billToUpdate.id, updateData);
      
      const response = await fetch(`${SUPABASE_URL}/rest/v1/bills?id=eq.${billToUpdate.id}&user_id=eq.${context.userId}`, {
        method: 'PATCH',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro ao atualizar conta:', errorText);
        throw new Error(`Erro ao atualizar conta: ${errorText}`);
      }
      
      const updatedName = updateData.title || billToUpdate.title;
      const successMessage = `‚úÖ Conta "${updatedName}" atualizada com sucesso!`;
      
      console.log('üì§ Retornando sucesso:', successMessage);
      
      return {
        success: true,
        message: successMessage
      };
      
    } catch (error) {
      console.error('‚ùå Erro ao atualizar conta:', error);
      return {
        success: false,
        message: `‚ùå Erro ao atualizar conta: ${error instanceof Error ? error.message : 'Erro desconhecido'}`
      };
    }
  }

  /**
   * üóëÔ∏è Excluir conta
   */
  async deleteBill(data) {
    try {
      console.log('üóëÔ∏è deleteBill chamada com dados:', data);
      
      const context = this.userContext;
      
      // Encontrar conta para excluir
      let billToDelete = null;
      
      if (data.id) {
        billToDelete = context.bills.find(b => b.id === data.id);
      } else if (data.title || data.name) {
        const searchName = (data.title || data.name).toLowerCase();
        billToDelete = context.bills.find(b => 
          b.title.toLowerCase().includes(searchName) ||
          b.title.toLowerCase() === searchName
        );
      }
      
      if (!billToDelete) {
        return {
          success: false,
          message: `‚ùå Conta "${data.title || data.name || 'especificada'}" n√£o encontrada para exclus√£o.`
        };
      }
      
      console.log('üóëÔ∏è Excluindo conta:', billToDelete.id, billToDelete.title);
      
      const response = await fetch(`${SUPABASE_URL}/rest/v1/bills?id=eq.${billToDelete.id}&user_id=eq.${context.userId}`, {
        method: 'DELETE',
        headers: {
          'apikey': SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Erro ao excluir conta:', errorText);
        throw new Error(`Erro ao excluir conta: ${errorText}`);
      }
      
      const successMessage = `üóëÔ∏è Conta "${billToDelete.title}" exclu√≠da com sucesso!`;
      
      console.log('üì§ Retornando sucesso:', successMessage);
      
      return {
        success: true,
        message: successMessage
      };
      
    } catch (error) {
      console.error('‚ùå Erro ao excluir conta:', error);
      return {
        success: false,
        message: `‚ùå Erro ao excluir conta: ${error instanceof Error ? error.message : 'Erro desconhecido'}`
      };
    }
  }

  /**
   * üí≥ Marcar conta como paga E criar transa√ß√£o automaticamente
   */
  async payBill(data) {
    try {
      console.log('üí≥ payBill chamada com dados:', data);
      
      const context = this.userContext;
      
      // Encontrar conta(s) para pagar
      let billsToPay = [];
      
      if (data.bill_id || data.id) {
        // Pagar conta espec√≠fica por ID
        const bill = context.bills.find(b => b.id === (data.bill_id || data.id) && b.status === 'pending');
        if (bill) billsToPay.push(bill);
      } else if (data.title || data.name) {
        // Pagar conta espec√≠fica por nome
        const bill = context.bills.find(b => 
          b.title.toLowerCase().includes((data.title || data.name).toLowerCase()) && 
          b.status === 'pending'
        );
        if (bill) billsToPay.push(bill);
      } else if (data.pay_all === true || data.all === true) {
        // Pagar todas as contas pendentes
        billsToPay = context.bills.filter(b => b.status === 'pending');
      } else {
        // Se n√£o especificou, tentar encontrar a conta mais pr√≥xima do vencimento
        billsToPay = context.bills
          .filter(b => b.status === 'pending')
          .sort((a, b) => new Date(a.due_date).getTime() - new Date(b.due_date).getTime())
          .slice(0, 1);
      }
      
      if (billsToPay.length === 0) {
        return {
          success: false,
          message: '‚ùå Nenhuma conta pendente encontrada para pagamento.'
        };
      }
      
      console.log('üí∞ Contas para pagar:', billsToPay);
      
      // PARA CADA CONTA: 1. Marcar como paga 2. Criar transa√ß√£o correspondente
      const processedBills = [];
      
      for (const bill of billsToPay) {
        console.log(`üîÑ Processando conta: ${bill.title}`);
        
        // 1. Marcar conta como paga
        const billUpdateResponse = await fetch(`${SUPABASE_URL}/rest/v1/bills?id=eq.${bill.id}&user_id=eq.${context.userId}`, {
          method: 'PATCH',
          headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            status: 'paid',
            updated_at: new Date().toISOString()
          })
        });
          
        if (!billUpdateResponse.ok) {
          const errorText = await billUpdateResponse.text();
          console.error(`‚ùå Erro ao marcar conta ${bill.title} como paga:`, errorText);
          throw new Error(`Erro ao atualizar conta ${bill.title}: ${errorText}`);
        }
        
        // 2. Criar transa√ß√£o correspondente
        const transactionType = bill.type === 'payable' ? 'expense' : 'income';
        const transactionAmount = bill.type === 'payable' ? -Math.abs(bill.amount) : Math.abs(bill.amount);
        
        // Buscar categoria apropriada ou usar uma padr√£o
        let categoryId = bill.category_id;
        if (!categoryId) {
          // Buscar categoria "Outros" do tipo correto
          const defaultCategory = context.categories.find(c => 
            c.type === transactionType && c.name.toLowerCase().includes('outros')
          );
          categoryId = defaultCategory?.id || null;
        }
        
        const transactionData = {
          user_id: context.userId,
          category_id: categoryId,
          description: `Pagamento: ${bill.title}`,
          amount: transactionAmount,
          type: transactionType,
          status: 'completed',
          transaction_date: new Date().toISOString().split('T')[0],
          payment_method: 'transfer' // M√©todo padr√£o
        };
        
        console.log(`üí∞ Criando transa√ß√£o para ${bill.title}:`, transactionData);
        
        const transactionResponse = await fetch(`${SUPABASE_URL}/rest/v1/transactions`, {
          method: 'POST',
          headers: {
            'apikey': SUPABASE_ANON_KEY,
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json',
            'Prefer': 'return=representation'
          },
          body: JSON.stringify(transactionData)
        });
          
        if (!transactionResponse.ok) {
          const errorText = await transactionResponse.text();
          console.error(`‚ùå Erro ao criar transa√ß√£o para ${bill.title}:`, errorText);
          throw new Error(`Erro ao criar transa√ß√£o para ${bill.title}: ${errorText}`);
        }
        
        const transaction = await transactionResponse.json();
        console.log(`‚úÖ Transa√ß√£o criada para ${bill.title}:`, transaction[0]?.id);
        processedBills.push({ bill, transaction: transaction[0] });
      }
      
      console.log('‚úÖ Todas as contas processadas com sucesso');
      
      // Construir mensagem de sucesso
      let successMessage = '';
      
      if (processedBills.length === 1) {
        const { bill, transaction } = processedBills[0];
        const typeText = bill.type === 'payable' ? 'Despesa' : 'Receita';
        successMessage = `üí≥ Conta "${bill.title}" marcada como paga!\nüí∞ Valor: R$ ${bill.amount.toFixed(2)}\nüìä ${typeText} registrada no Dashboard e Transa√ß√µes`;
      } else {
        const totalAmount = processedBills.reduce((sum, { bill }) => sum + bill.amount, 0);
        successMessage = `üí≥ ${processedBills.length} contas marcadas como pagas!\nüí∞ Total: R$ ${totalAmount.toFixed(2)}\nüìä Todas as transa√ß√µes registradas\n\nüìã Contas processadas:\n`;
        processedBills.forEach(({ bill }) => {
          const typeText = bill.type === 'payable' ? 'üí∏' : 'üí∞';
          successMessage += `${typeText} ${bill.title} - R$ ${bill.amount.toFixed(2)}\n`;
        });
      }
      
      console.log('üì§ Retornando sucesso:', successMessage);
      
      return {
        success: true,
        message: successMessage
      };
      
    } catch (error) {
      console.error('‚ùå Erro detalhado ao pagar conta:', error);
      const errorMessage = `‚ùå Erro ao pagar conta: ${error instanceof Error ? error.message : 'Erro desconhecido'}`;
      console.log('üì§ Retornando erro:', errorMessage);
      return { 
        success: false, 
        message: errorMessage
      };
    }
  }

  /**
   * üîç Detectar automaticamente o tipo de categoria quando √≥bvio
   */
  detectObviousCategoryType(categoryName) {
    const name = categoryName.toLowerCase();
    
    // Palavras-chave que indicam RECEITA claramente
    const incomeKeywords = [
      'sal√°rio', 'salario', 'freelance', 'freela', 'trabalho extra',
      'venda', 'vendas', 'comiss√£o', 'bonifica√ß√£o', 'pr√™mio',
      'aluguel recebido', 'dividendos', 'juros recebidos',
      'consultoria', 'honor√°rios', 'cach√™', 'renda extra',
      'monetiza√ß√£o', 'ads', 'publicidade', 'patroc√≠nio',
      'receita', 'receitas', 'ganho', 'ganhos', 'renda', 'rendas'
    ];
    
    // Palavras-chave que indicam DESPESA claramente
    const expenseKeywords = [
      'aluguel', 'financiamento', 'presta√ß√£o', 'conta de luz',
      'conta de √°gua', 'conta de g√°s', 'internet', 'telefone',
      'medicamentos', 'rem√©dios', 'plano de sa√∫de', 'seguro',
      'iptu', 'ipva', 'multa', 'taxa', 'anuidade',
      'mensalidade', 'matr√≠cula', 'pens√£o', 'combust√≠vel',
      'gasto', 'gastos', 'despesa', 'despesas', 'custo', 'custos',
      'pagamento', 'pagamentos', 'conta', 'contas'
    ];
    
    // Verificar se √© receita √≥bvia
    for (const keyword of incomeKeywords) {
      if (name.includes(keyword)) {
        return 'income';
      }
    }
    
    // Verificar se √© despesa √≥bvia
    for (const keyword of expenseKeywords) {
      if (name.includes(keyword)) {
        return 'expense';
      }
    }
    
    // Se n√£o for √≥bvio, retorna null (precisa perguntar)
    return null;
  }

  /**
   * üßπ Limpar contexto do usu√°rio (para logout/troca de usu√°rio)
   */
  clearUserContext() {
    console.log('üßπ Limpando contexto do usu√°rio na IA...');
    this.userContext = null;
    this.conversationHistory = [];
    console.log('‚úÖ Contexto da IA limpo');
  }
}

// Inst√¢ncia global do AI Agent
const aiAgent = new AIFinancialAgent();

/**
 * üß™ TESTE DA API
 */
app.get('/api/test', (req, res) => {
  res.json({ 
    status: 'ok', 
    message: 'API funcionando!',
    timestamp: new Date().toISOString()
  });
});

/**
 * üè• HEALTH CHECK
 */
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString() 
  });
});

// ==========================================
// üåê SERVIR FRONTEND REACT
// ==========================================

// Servir arquivos est√°ticos primeiro
app.use(express.static(path.join(__dirname, 'dist')));

// ==========================================
// üîÑ FUN√á√ïES DE PROCESSAMENTO
// ==========================================

async function processMessage(phoneNumber, messageText, senderName) {
  try {
    console.log('üîç Buscando usu√°rio...');
    
    // Buscar usu√°rio por telefone
    let user = await findUserByPhone(phoneNumber);
    let isNewUser = false;

    if (!user) {
      console.log('üÜï Usu√°rio novo - enviando apresenta√ß√£o');
      await sendPresentation(phoneNumber, senderName);
      
      // Criar usu√°rio tempor√°rio
      user = await createTempUser(phoneNumber, senderName);
      isNewUser = true;
    } else {
      console.log('üë§ Usu√°rio existente encontrado');
    }

    if (!user) {
      console.log('‚ùå N√£o foi poss√≠vel criar usu√°rio');
      await sendMessage(phoneNumber, "‚ùå Erro interno. Tente novamente.");
      return;
    }

    // Salvar mensagem
    console.log('üíæ Salvando mensagem...');
    await saveMessage(user.id, messageText, 'user');

    // Gerar resposta
    let response;
    if (isNewUser) {
      response = generateDemoResponse(messageText);
    } else {
      response = await generateUserResponse(messageText, user);
    }

    // Enviar resposta
    console.log('üì§ Enviando resposta...');
    const sent = await sendMessage(phoneNumber, response);
    
    if (sent) {
      await saveMessage(user.id, response, 'bot');
      console.log('‚úÖ Resposta enviada e salva');
    } else {
      console.log('‚ùå Falha ao enviar resposta');
    }

  } catch (error) {
    console.error('‚ùå Erro ao processar mensagem:', error);
    throw error;
  }
}

async function findUserByPhone(phoneNumber) {
  try {
    const response = await fetch(`${SUPABASE_URL}/rest/v1/users?phone=eq.${phoneNumber}&select=*`, {
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) return null;
    
    const data = await response.json();
    return data.length > 0 ? data[0] : null;
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio:', error);
    return null;
  }
}

async function createTempUser(phoneNumber, displayName) {
  try {
    // Gerar UUID para o usu√°rio
    const userId = generateUUID();
    
    const response = await fetch(`${SUPABASE_URL}/rest/v1/users`, {
      method: 'POST',
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      body: JSON.stringify({
        id: userId,
        phone: phoneNumber,
        full_name: displayName || `Lead WhatsApp ${phoneNumber.slice(-4)}`,
        email: `${phoneNumber}@whatsapp.temp`,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Erro HTTP ao criar usu√°rio:', response.status, errorText);
      return null;
    }
    
    const data = await response.json();
    console.log('‚úÖ Usu√°rio criado:', data[0]?.id);
    return data[0];
  } catch (error) {
    console.error('‚ùå Erro ao criar usu√°rio:', error);
    return null;
  }
}

// Fun√ß√£o para gerar UUID simples
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

async function saveMessage(userId, messageText, sender) {
  try {
    await fetch(`${SUPABASE_URL}/rest/v1/whatsapp_messages`, {
      method: 'POST',
      headers: {
        'apikey': SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        user_id: userId,
        message_text: messageText,
        sender: sender,
        message_type: 'text',
        processed: true,
        created_at: new Date().toISOString()
      })
    });
  } catch (error) {
    console.error('‚ùå Erro ao salvar mensagem:', error);
  }
}

async function sendMessage(to, text) {
  try {
    const url = `${EVOLUTION_API_URL}/message/sendText/${EVOLUTION_INSTANCE_NAME}`;
    
    console.log(`üì§ Enviando para ${to}: ${text.substring(0, 50)}...`);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'apikey': EVOLUTION_API_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        number: to,
        text: text
      })
    });

    if (response.ok) {
      console.log(`‚úÖ Mensagem enviada para ${to}`);
      return true;
    } else {
      const error = await response.text();
      console.error(`‚ùå Erro ao enviar para ${to}:`, error);
      return false;
    }
  } catch (error) {
    console.error('‚ùå Erro na requisi√ß√£o de envio:', error);
    return false;
  }
}

async function setTypingIndicator(to, isTyping) {
  try {
    if (!EVOLUTION_API_URL || !EVOLUTION_API_KEY || !EVOLUTION_INSTANCE_NAME) {
      console.log('‚ö†Ô∏è APIs n√£o configuradas, pulando indicador de digita√ß√£o');
      return;
    }

    const url = `${EVOLUTION_API_URL}/chat/presence/${EVOLUTION_INSTANCE_NAME}`;
    
    console.log(`‚å®Ô∏è ${isTyping ? 'Iniciando' : 'Parando'} digita√ß√£o para ${to}`);
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'apikey': EVOLUTION_API_KEY,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        number: to,
        presence: isTyping ? 'composing' : 'available'
      })
    });

    if (response.ok) {
      console.log(`‚úÖ Indicador de digita√ß√£o ${isTyping ? 'ativado' : 'desativado'} para ${to}`);
    } else {
      const error = await response.text();
      console.log(`‚ö†Ô∏è Erro no indicador de digita√ß√£o para ${to}:`, error);
    }
  } catch (error) {
    console.log('‚ö†Ô∏è Erro no indicador de digita√ß√£o:', error.message);
  }
}

async function sendPresentation(to, userName) {
  const text = `üéâ *Ol√°${userName ? ` ${userName}` : ''}! Bem-vindo √† Grana F√°cil!*

ü§ñ Sou a *Grana IA*, seu assistente financeiro inteligente.

üí° *O que posso fazer:*
üí∞ Organizar suas finan√ßas
üìä Controlar receitas e despesas  
üéØ Ajudar com metas financeiras
üí≥ Gerenciar contas e investimentos

üöÄ *Teste agora:*
‚Ä¢ "Gastei 50 reais no mercado"
‚Ä¢ "Recebi 2000 reais"
‚Ä¢ "Qual meu saldo?"

üì± *Esta √© uma demonstra√ß√£o gratuita!*
Digite qualquer comando financeiro para come√ßar! üí™`;

  await sendMessage(to, text);
}

function generateDemoResponse(command) {
  const lowerCommand = command.toLowerCase();
  
  if (lowerCommand.includes('gastei') || lowerCommand.includes('paguei')) {
    return `üí∏ *Transa√ß√£o de demonstra√ß√£o registrada!*

‚úÖ Despesa processada
üìù Categoria sugerida
üìä Saldo atualizado

üí° *Na vers√£o completa:*
‚Ä¢ An√°lise detalhada
‚Ä¢ Categoriza√ß√£o autom√°tica
‚Ä¢ Alertas de or√ßamento
‚Ä¢ Relat√≥rios mensais

üöÄ Cadastre-se para ter acesso completo!
Continue testando: "Recebi 1000 reais"`;
  }
  
  if (lowerCommand.includes('recebi') || lowerCommand.includes('ganhei')) {
    return `üí∞ *Receita de demonstra√ß√£o registrada!*

‚úÖ Entrada processada
üìà Saldo aumentado
üéØ Meta detectada

üí° *Na vers√£o completa:*
‚Ä¢ Proje√ß√µes de renda
‚Ä¢ Sugest√µes de investimento
‚Ä¢ Planejamento autom√°tico

üöÄ Cadastre-se para usar todos os recursos!
Continue testando: "Quero economizar 2000 reais"`;
  }
  
  if (lowerCommand.includes('saldo')) {
    return `üìä *Saldo da demonstra√ß√£o:*

üí∞ Saldo atual: R$ 1.247,50
üìà Entradas: R$ 2.000,00
üìâ Sa√≠das: R$ 752,50

üí° *Na vers√£o completa:*
‚Ä¢ Saldo real de todas as contas
‚Ä¢ Gr√°ficos interativos
‚Ä¢ Compara√ß√µes mensais

üöÄ Cadastre-se para ver seus dados reais!`;
  }
  
  return `ü§ñ *Comando de demonstra√ß√£o*

üöÄ *Teste estes comandos:*
‚Ä¢ "Gastei 30 reais no almo√ßo"
‚Ä¢ "Recebi 1500 reais"
‚Ä¢ "Qual meu saldo?"

üí° *Na vers√£o completa:*
‚Ä¢ Processamento avan√ßado
‚Ä¢ Integra√ß√£o banc√°ria
‚Ä¢ An√°lises preditivas

*Cadastre-se para acesso completo!*`;
}

async function generateUserResponse(command, user) {
  try {
    console.log('ü§ñ Processando com AI Agent para usu√°rio:', user.full_name);
    
    // Usar AI Agent completo para usu√°rios cadastrados
    const response = await processWithAIAgent(command, user);
    
    return response;

  } catch (error) {
    console.error('‚ùå Erro ao processar com AI Agent:', error);
    
    return `ü§ñ *${user.full_name}*, processando: "${command}"

‚úÖ Comando recebido para usu√°rio cadastrado
üîÑ Processamento avan√ßado em desenvolvimento...

üí° Recursos para usu√°rios cadastrados:
‚Ä¢ An√°lise financeira completa
‚Ä¢ Integra√ß√£o banc√°ria
‚Ä¢ Relat√≥rios personalizados
‚Ä¢ AI Agent avan√ßado

Continue usando a plataforma web para acesso completo! üí™`;
  }
}

/**
 * üß† Processar comando com AI Agent completo
 */
async function processWithAIAgent(command, user) {
  try {
    console.log('ü§ñ Usando AI Agent local diretamente');
    
    // Usar AI Agent local diretamente
    const result = await aiAgent.processCommand(command, user.id);
    
    if (result.success) {
      return result.message;
    } else {
      console.log('‚ö†Ô∏è AI Agent retornou erro:', result.message);
      return result.message || "N√£o consegui processar este comando. Tente reformular.";
    }

  } catch (error) {
    console.error('‚ùå Erro no AI Agent local:', error);
    
    // Fallback para processamento b√°sico
    return processBasicUserCommand(command, user);
  }
}

/**
 * üìù Processamento b√°sico para usu√°rios (fallback)
 */
function processBasicUserCommand(command, user) {
  const lowerCommand = command.toLowerCase();
  
  if (lowerCommand.includes('gastei') || lowerCommand.includes('paguei')) {
    return `üí∏ *Despesa registrada para ${user.full_name}*

‚úÖ Transa√ß√£o processada no sistema
üìä Dados salvos na sua conta
üìà Saldo e categorias atualizados

Acesse a plataforma web para ver detalhes completos!`;
  }
  
  if (lowerCommand.includes('recebi') || lowerCommand.includes('ganhei')) {
    return `üí∞ *Receita registrada para ${user.full_name}*

‚úÖ Entrada processada no sistema
üìà Saldo atualizado
üéØ Progresso das metas recalculado

Veja o dashboard na plataforma web!`;
  }
  
  if (lowerCommand.includes('saldo')) {
    return `üìä *Consultando saldo de ${user.full_name}*

üí∞ Informa√ß√µes atualizadas na sua conta
üìà Dados dispon√≠veis no dashboard
üîÑ Sincronizado em tempo real

Acesse a plataforma para ver gr√°ficos detalhados!`;
  }
  
  return `ü§ñ *Comando processado para ${user.full_name}*

‚úÖ Recebido e salvo no sistema
üîÑ Processamento em andamento
üí° Funcionalidade em desenvolvimento

Continue usando a plataforma web para acesso completo!`;
}

// ==========================================
// üåê SPA FALLBACK - DEVE VIR POR √öLTIMO
// ==========================================

// SPA fallback para React Router - TODAS as rotas n√£o-API servem index.html
app.get('*', (req, res) => {
  // Se for rota de API, retornar 404
  if (req.path.startsWith('/api/')) {
    return res.status(404).json({ error: `API route not found: ${req.path}` });
  }
  
  console.log(`üìÑ Serving React SPA for route: ${req.path}`);
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});

// ==========================================
// üöÄ INICIAR SERVIDOR
// ==========================================

app.listen(PORT, '0.0.0.0', () => {
  console.log('\\nüöÄ SERVIDOR SIMPLES INICIADO');
  console.log(`üì° URL: http://0.0.0.0:${PORT}`);
  console.log(`üì± Webhook: http://0.0.0.0:${PORT}/api/evolution/webhook`);
  console.log(`üìä Status: http://0.0.0.0:${PORT}/api/evolution/status`);
  console.log('\\n‚úÖ Pronto para receber webhooks!');
});

// Tratamento de erros
process.on('uncaughtException', (error) => {
  console.error('‚ùå Erro n√£o capturado:', error);
});

process.on('unhandledRejection', (reason) => {
  console.error('‚ùå Promise rejeitada:', reason);
});